<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>Chapter 1. Aspect-Oriented Programming</title><link rel="stylesheet" href="docbook.css" type="text/css"></link><meta name="generator" content="DocBook XSL Stylesheets V1.71.0"></meta><link rel="start" href="index.html" title="phpAspect documentation"></link><link rel="up" href="index.html" title="phpAspect documentation"></link><link rel="prev" href="preface.html" title="Preface"></link><link rel="next" href="helloworld.html" title="Chapter 2. Hello world"></link><script xmlns="" src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script><script xmlns="" type="text/javascript">
    _uacct = "UA-259974-1";
    urchinTracker();
    </script></head><body><a xmlns="" href="http://phpaspect.org"><img src="http://phpaspect.org/images/phpaspect.png" alt="phpAspect Logo" style="border:0;"></a><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 1. Aspect-Oriented Programming</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="preface.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="helloworld.html">Next</a></td></tr></table><hr></hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="aop"></a>Chapter 1. Aspect-Oriented Programming</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="aop.evolution-of-paradigms"></a>Programming evolutions</h2></div></div></div><p>
        In order to always improve the modularization and the reuse
        of programs source code, Programming paradigms never ceased
        to be more and more abstract models.
        Object-Oriented Programming have shown very powerful
        abilities to modularize vertical concerns into single entities.
        Packages, classes, and methods all help programmers to encapsulate
        concerns into single entities. But although these methodologies
        can't successfully encapsulate horizontal concerns, also called
        crosscutting concerns, because they exist in many parts of the program.
        </p><div class="figure"><a id="evolution-of-paradigms"></a><p class="title"><b>Figure 1.1. Programming evolutions</b></p><div class="figure-contents"><div><img src="figures/evolution-of-paradigms.png" alt="Programming evolutions"></img></div></div></div><br class="figure-break"></br><p>
          So we can all ask ourselves: what will be the programming
          paradigm of tomorrow ?
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="aop.technicals-aspects-in-oop"></a>Technical concerns in OOP</h2></div></div></div><p>
        In Object-Oriented Programming, classes are often polluted
        by cross-cutting concerns (also called technical concerns)
        tangled with basic functionalities (also called the business
        logic concern).
        These cross-cutting concerns can by various: transactions, security, logging, persistence,
        session, etc.
        </p><div class="figure"><a id="concerns-in-oop"></a><p class="title"><b>Figure 1.2. In OOP, the business logic has strong dependencies with technicals technical modules addresses.</b></p><div class="figure-contents"><div><img src="figures/concerns-in-oop.png" alt="In OOP, the business logic has strong dependencies with technicals technical modules addresses."></img></div></div></div><br class="figure-break"></br><p>
          This pollution has many symptoms:
            </p><div class="itemizedlist"><ul type="disc"><li>Code tangling</li><li>Code scattering</li><li>Code comprehension</li><li>Code reusability</li><li>Code evolution</li></ul></div><p>
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="aop.aspect-oriented-programming"></a>Aspect-Oriented Programming</h2></div></div></div><p>
        In software engineering, the programming paradigms of 
        aspect-oriented programming (AOP) attempt to aid programmers
        in the separation of these cross-cutting concerns.
        AOP is defining all mechanisms for:
        </p><div class="itemizedlist"><ul type="disc"><li>Writing aspects as a new software entiy.</li><li>Weaving technical concerns on business logic.</li></ul></div><p>
      </p><div class="figure"><a id="ioc-in-aop"></a><p class="title"><b>Figure 1.3. Inversion of control in AOP.</b></p><div class="figure-contents"><div><img src="figures/ioc-in-aop.png" alt="Inversion of control in AOP."></img></div></div></div><br class="figure-break"></br></div><p>
    An aspect has the following anatomy:
      </p><div class="itemizedlist"><ul type="disc"><li>Joinpoints.</li><li>Pointcuts.</li><li>Advices.</li><li>Inter-type declarations.</li><li>Attributes.</li><li>Methods.</li></ul></div><p>
    </p><p>
    The joinpoint notion provides all the mechanisms to identify
    patterns in the program flow.
    </p><div class="figure"><a id="joinpoints"></a><p class="title"><b>Figure 1.4. Examples of joinpoints.</b></p><div class="figure-contents"><div><img src="figures/joinpoints.png" alt="Examples of joinpoints."></img></div></div></div><p><br class="figure-break"></br>
        </p><div class="itemizedlist"><ul type="disc"><li>Method execution (1).</li><li>Attribute writing/reading (2).</li><li>Object construction (3).</li><li>Method call (4).</li><li>Object descrution (5).</li><li>Exception throwing (6).</li></ul></div><p>
    </p><p>
    A pointcut is a logical composition of joinpoints.
    </p><p>
    Advices represents the injected code into poincuts.
    There are three kinds of advices:
        </p><div class="itemizedlist"><ul type="disc"><li>Before.</li><li>Around (instead).</li><li>After.</li></ul></div><p>
    </p><p>
    Aspects can declare attributes, methods, constants and constructors that are owned by other types. These are called inter-type declarations.
    </p></div><div class="navfooter"><hr></hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="preface.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="helloworld.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Preface </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 2. Hello world</td></tr></table></div><div xmlns="" class="copyright-notice"><a href="appendixes.copyright.html">Copyright</a> © 2006-2007 <a href="mailto:wcandillon@elv.telecom-lille1.eu">William Candillon</a>
      and <a href="mailto:vanwormhoudt@telecom-lille1.eu">Gilles Vanwormhoudt</a>.
    </div></body></html>
